% !TeX spellcheck = en_US
\section{Problem Analysis}
The derailed project we consider is this paper is our 2\textsuperscript{nd} year project, which was divided into two parts. In the first part of the project we cooperated with a Singaporean group (SMU) over five weeks to build a rental system. We built the server part of the system, while the Singaporean group simultaneously developed the client to consume our services.

\textbf{[ TODO: Add references to the events described in this section from the 'Getting back on track' section, whenever we decide for or against methods. The choices should be made from the observations we make in this section. ]}

\textbf{[ TODO: Cut away any content which is not essential to the rest of the report. ]}

We had chosen to write the server using F\#, a new language we were learning in parallel with the project. We thought it would be an excellent opportunity to see how it performed when applied to a real project.
Working with the .NET platform, we had also decided to use WCF to publish our services, something we had experience with from the previous semester. Previously this had been SOAP, but we saw several benefits from designing the API RESTfully, although this would be another new area to explore.
Having talked with our tutor, we were advised to add a thin layer of C\# code between the WCF layer and our backend code in F\#, since F\# did not play that well with WCF yet. The sole purpose of the C\# code would be to pass on requests to the backend and give back the results received.
At last we also decided against using the ADO.NET Entity Framework and instead write our own database communication code to maximize freedom and transparency of the persistence layer.
We knew it would be a lot of work, but decided to do all of it anyway, even though the collaboration also would be a new experience to us. This decision was probably the main source of later problems, since working with new technologies opens up for a number of unknown factors that impacts estimations.

As development methodology we chose not to use SCRUM, since most of the group based on previous experience felt that we would spend more time to set it up than we would gain from using it. Also our individual time schedules and short time frame made it difficult to set up sprints of effective lengths, where everybody would be able to participate. We did not anticipate how much the lack of detailed planning affected our work, but expected that the time we saved would exceed the extra spent from not planning.

After a preparation period of about a month, the collaboration was about to begin, at which point no work had been performed yet. The requirements of the system were to be negotiated with SMU, and so were the interface of our part of the system.

A week after the preparations had begun, the requirements were in place and the first half of a very detailed API documentation were ready, although documentation of the full API had been agreed to be done. For consistency reasons a single person had been designated to write the document, but since we did not have experience writing such documents, the extent came as a surprise.

With only four weeks left of the collaboration, SMU needed our server to provide functionality soon, and the part of the API already documented was agreed to be implemented and running by the end of the week. Since we did not use SCRUM, time was not spend estimating the extent of the work in detail. Time was short, but with hard work we estimated the deadline to be possible.
Had we used familiar tools and languages, the estimates would probably had been correct, but none of us had taken the many new technologies into account.

Without planning our overview also got lost: Layers of the functionality was distributed among the team members, but time was not spent in the group talking about the overall architecture.

By the end of the week, all members had experienced problems to some extent because of the new technology, and the code were by no means ready for deployment.
Problems figuring out how to configure WCF properly arose; it turned into a bigger task than anticipated getting the C\# layer and the frontend of the F\# backend to communicate; and the F\# code, its structure, and its internal communication, suffered from our lacking knowledge of the language and how to built generic, modular systems using it.

At the beginning of next week the WCF layer was not finished yet, and though the backend seemed to be ready, we could not deploy. The structural problems started to show, and after an extensive code review it became apparent that refactoring would be needed.
SMU began asking for a schedule of when each server feature would be implemented, which they were given, although the dates were set arbitrarily as they needed to in order for all functionality to be fitted into the schedule. Looking back, this schedule was highly unrealistic, but we deemed it possible, probably because no estimations of each required feature had been made.

Thursday, four days over deadline, the first part of the service was deemed ready for deployment, at which point some refactoring also had been made. Thursday was spent deploying the system, which turned out to both be missing agreed functionality and containing severe bugs. The system was deployed, but parts of the system were not functional and essential concurrency-controlling code had to be commented out in order for the system to be functional.

The second half of the web service API was ready the next Monday where it was accepted by SMU. Next we carried out refactorizations, which had shown to be essential, and planned our activities for the easter holidays, in which the team would not be able to assemble. After the holidays only a week was left of the collaboration, which we reserved for bug fixing and deployment. The layers of functionality was split between the team members to be developed individually during the holidays.

When the holidays ended, the WCF layer had been refactored completely, and although it was meant to be thin, this was by no means the case. It was missing almost all functionality that should had been implemented during the holidays, and so were the case for many other layers of planned functionality.
Not all problems which had shown during the deployment of the first system part had been fixed yet, and large parts of the system were still untested.

Our deadline was in just four days, and it all became very hectic with work during both day and night. In the end not all requirements were fulfilled, much code was untested, entire parts of planned functionality had been dropped, and the overall quality of the code was poor. It was frustrating to debug and hence maintain, and the code contained several bugs, which was found during the following days where none of the team members really had the time to fix them.

After SMU had their deadline they asked us if we could give them some reflection on the collaboration, which gave us a chance to reflect on our process as well. We realized how far into the semester we were and how close our own deadline was. We saw how much time you could potentially waste, when you do not prepare properly to a given project, and how this affects the quality of the product. At this point we realized that the project had derailed completely - and something had to be done to get it back on track!
\newpage