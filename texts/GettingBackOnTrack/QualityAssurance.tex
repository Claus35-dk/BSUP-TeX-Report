\subsection{Quality assurance}
To be able to measure the quality of our client we use the requirements we set to the client along with a test strategy to ensure as little errors as possible and the methods described earlier in this chapter. We move from the initial level of Capability Maturity Model while developing the server to the managed level during the development of the client. We kept to the initial level during the development of the server, by developing as we went along.

The usage of a test strategy, increases the likelihood of finding errors early and correcting them, thereby minimizing the amount of time on debugging. When we define the test criteria, combined with the product requirements, we get one way of measuring quality.
Regarding our project, we have decided on a minimal test-strategy. The program's quality may suffer from this, but the first part of the project was done without any strategy. It will better testing than the first part of the project, though we were forced to keep testing at a minimal, due to lack of time.

 If the product fulfills the requirements and pass the tests, depending on the tests, its reliability has been proved as well. Which is one of CISQ's 5 major desirable characteristics. The other 4 are; efficiency, security, maintainability and size.
 Efficiency means that there is minimal to none code duplication, optimized algorithms etc. That the code runs as smooth and fast as possible at production. 
 Security how vulnerable the code is the direct attacks, if there are any obvious breaches affect this criteria.
 Maintainability, how easy is it to understand and edit the product once in production. Documented code and the clear use of known design patterns does a lot for the maintainability. 
 Size is not a quality indicator per se, but can be used to asses the time needed to complete the product.
 
 The efficiency parameter comes partly from our planning and software design and partly from our implementation.
 Our design assumes a minimal amount of the security on the client side, most of the security is done by the server. We do secure sensitive information, but the security were not meant to sustain direct malicious intent.
 The client is maintainable, we have a well documented and responsibility driven product, making for others to understand and maintain our code. 
 It can however be used determined if we have made it too complicated. In the instance of the server if we had made interfaces of all modules we would have seen a overly complex system, but we only discovered this after the server was almost done.
